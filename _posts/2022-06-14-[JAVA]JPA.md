---
author_profile: true
categories: "java"
toc: true
toc_sticky: true
---

# 1.JPA란?
JPA(Java Persistence API)는 자바에서 제공하는 **관계형 데이터베이스 처리용 API다.** JPA는 라이브러리가 아니라 **인터페이스다.** 즉, JPA 자체가 특정 기능을 하지 못한다. JPA는 인터페이스로 단지 RDBMS(관계형 데이터베이스)를 어떻게 사용해야 하는지(Java ORM 기술)에 대한 명세(프로그램의 구조와 기능을 상세하게 기술한 문서)로 볼 수 있다. 이런 JPA인터페이스를 상속받은 구현체들은 Hibernate, EclipseLink, Apache OpenJPA 등이 있다. 이 구현체들을 ORM 프레임워크라고 한다.

자바 JPA는 **javax.persistence** 패키지로 제공된다.

## 1.1 ORM
JPA는 ORM이고, ORM은 Persistence Framework의 한 종류다.
- Persistence Framework : persistence는 영속성이라는 뜻으로 persistence framework는 데이터를 DB에 영구저장함으로써 데이터에 영속성(사라지지 않게)을 부여해주는 장치라고 생각할 수 있다.
    - ORM(Object Relational Mapping) : 객체와 RDBMS객체(테이블)를 매핑하는 기술. 즉, 자바 객체를 RDBMS객체로 만들거나 RDBMS객체를 자바 객체로 만든다는 의미다. 
    - SQL Mapper : 객체와 SQL문을 매핑하는 기술.

## 1.2 JPA 장점
- DB마다 다른 sql문을 몰라도 된다 ( 특정 DB에 종속되지 않음 )
데이터베이스마다 sql문법이 조금씩 다르다. 그럼 사용하는 데이터베이스가 달라질 때마다 그에 맞춰서 sql문법을 공부해야 한다. 예를 들어 mysql에서는 varchar, oracle에서는 varchar2라는 타입을 문자열 타입으로 쓴다. 자바에서 mysql을 이용하려고 하는데 JDBC를 이용해 쿼리문을 작성할 때 varchar2타입을 사용하면 문제가 생긴다. 하지만 **JPA는 DB별 방언 처리기(Hibernate,EclipseLink 등등) 설정만 해주면 알아서 sql문법에 맞게 sql쿼리문을 생성해준다.** 이를 통해 sql문법에 대한 부담을 줄일 수 있다.

- 반복적인 SQL문 작성이 필요없다 ( 생산성 향상 )
JPA는 간단한 sql 쿼리문에 대한 메서드를 제공한다. 간단한 예를 들어본다.

```java
Member oneFindMember = em.find(Member.class, "id1");
```

위 코드에서 find메서드가 찾고자 하는 엔티티에서 primary key를 이용해 검색하는 기능을 제공한다. 즉, 자주 쓰이는 select쿼리문을 미리 메서드로 만들어 놓은 것이다. JDBC처럼 직접 select쿼리문을 작성할 필요가 없다.( 복잡한 sql문은 JPQL을 이용해 따로 생성해야됨 )

- 필드 수정에 따른 SQL문 수정을 안해도 된다 ( 유지보수 용이 )
필드값이 수정되었을 때 매핑된 엔티티만 수정하면 된다. 

# 2.JPA 실행구조
<img width="749" alt="JPA실행구조도" src="https://user-images.githubusercontent.com/96512568/173839714-e0dfed0f-fd0e-4228-b4e3-7ce411d61801.png">


# 3.JPA 구성요소
## 
- @Entity : DB테이블과 매핑되는 클래스를 의미한다.
    - @Entity(name = "사용할엔티티명") : JPA에서 사용할 엔티티명을 설정한다. 지정하지 않으면 클래스명을 사용하게 된다.
- @Table : Entity와 매핑할 테이블을 지정한다.
    - @Table(name = "사용할테이블명") : 매핑할 테이블명을 설정한다. 지정하지 않으면 엔티티명을 사용하게 된다.
- @Id : Primary key로 설정한다
- @GeneratedValue : 
    - @GeneratedValue(strategy = GenerationType.IDENTITY) : mysql의 auto_increment설정. 즉, 값이 중복되지 않고 알아서 +1되도록 설정한다.
- @Column : 필드로 설정한다
    -Column(name = "사용할컬럼명') : DB에 저장될 컬럼명을 설정한다.

# 4.JPA 클래스, 인터페이스 관계
- Persistence : createEntityManagerFactory메서드로 EntityManageFactory객체를 생성
- EntityManagerFactory : createEntityManager메서드로 EntityManager객체를 생성. Application 실행 시 하나만 생성됨
- EntityManager : getTransaction메서드로 EntityTransaction객체를 생성. 데이터를 DB에 저장하기 전에 Persistent Context에 저장해 관리함
- EntityTransaction : EntityManager와 일대일 관계로 EntityManager들의 작업은 EntityTransaction 클래스에 의해서 유지됨
- Entity : 영속객체로 데이터베이스에 기록될 객체다
- Query : sql문장 직접 타이핑할 수 있게함
- <img width="448" alt="JPA클래스관계" src="https://user-images.githubusercontent.com/96512568/173968696-49e29da4-daa5-47d0-9556-9873ac3b133b.png">
- Persistent Context(영속성 컨텍스트) : Entity가 DB에 영구저장되도록 지원하는 환경. EntityManager로 접근가능함
    - persistent context와 관련된 entity상태종류
        - 비영속(new) : 아직 persistent context에 저장되지 않음
        - 영속(managed) : persistent context에 저장됨
        - 준영속(detached) : persistent context에 저장되었다가 분리됨
        - 삭제(removed) : persistent context, DB에서 삭제됨
    - persistent context 사용이유
        - 버퍼메모리와 같은 느낌의 성능 향상 ( 쓰기지연 ) : Application과 DB사이에 중간다리같은 역할로 Application에서 persistent context로 DB에 저장할 내용을 모았다가 한번에 DB로 저장하는 식의 동작으로 Application과 DB사이를 오가는 시간을 줄여 성능을 향상시킨다.
        - 1차캐시 : persistent context에 저장되는 캐시로 EntityManager의 find메서드를 이용할 때 DB까지 접속해 검색할 필요없이 빠르게 1차캐시를 조회해 값이 있으면 반환한다.
- <img width="635" alt="persistentcontext" src="https://user-images.githubusercontent.com/96512568/173993952-39771d8f-6d78-4026-88a7-b4ba0c6b77b6.png">





# 5.JPQL
EntityManager로 Query객체 생성

JPQL에는 엔티티명을 사용해야 한다. 만약 엔티티명이 따로 지정되지 않았다면 테이블명을 사용한다.
별칭(Alias)이 필수다. from 뒤에 오는 엔티티에 대한 별칭이 필수다.

- 둘다 나중에 값을 넣어주는 포매팅 기술이라고 생각하면 된다. ':'는 ':A'라고 한다면 나중에 'query.setParameter("A",넣어줄값)'이런식으로 값을 대입해주고, '?'는 '?1'이라고 한다면 나중에 'query.setParameter(1,넣어줄값)'이런식으로 값을 대입해준다.
- : : 이름 기준 파라미터
- ? : 위치 기준 파라미터

- 페이징API
query.setFirstResult(10);
query.setMaxResults(20);
query.getResultList();
setFirstResult(int startPosition) : 조회 시작 위치(0부터 시작)
setMaxResults(int maxResult) : 조회활 데이터 수



JPQL을 실행하기 위한 쿼리 객체
- TypeQuery : 반환할 타입을 명확하게 지정할 수 없을 때 사용
- Query : 반환할 타입을 명확하게 지정할 수 있을 때 사용

- 조인
    - 조인


# 6.JPA 실행순서
1. EntityManagerFactory객체 생성
2. EntityManager객체 생성 
3. EntityTransaction객체 생성 및 시작
4. EntityTransaction내용 작성 및 저장
5. EntityTransaction객체 커밋
6. 반환

## 6.1 EntityManagerFactory객체 생성

```java
EntityManagerFactory emf = Persistence.createEntityManagerFactory("dbinfo");
```
 
## 6.2 EntityManager객체 생성 

```java
EntityManager em = emf.createEntityManager();
```
 
## 6.3 EntityTransaction객체 생성 및 시작

```java
EntityTransaction tx =em.getTransaction();
tx.begin();
```

## 6.4 EntityTransaction내용 작성 및 저장
트랜잭션에 대한 내용을 작성한 뒤 EntityManager의 메서드들을 사용하는데 용도에 대해 알아본다.
- persist() : Application에서 작성한 트랜잭션을 Persistent Context로 저장
- flush() : Persistent Context에 저장된 트랜잭션을 DB로 임시저장
- clear() : Persistent Context에 저장된 트랜잭션을 모두 삭제

```java
Team t1 = Team.builder()
				.teamName("농구팀")
				.members(new ArrayList<>()) // 빌더패턴에서는 이렇게 초기화를 안하면 그냥 null로 인식해버림
				.build();
em.persist(t1);
em.flush();
em.clear();
```
 
## 6.5 EntityTransaction객체 커밋
EntityTransaction의 메서드로 DB에 영구저장하는 단계다.
- commit() : Application에서 작성한 트랜잭션, Persistent Context에 저장된 트랜잭션, DB에 임시저장된 트랜잭션을 모두 DB에 영구저장

```java
tx.commit();
```

## 6.6 반환
더 이상 사용하지 않는 EntityManger객체와 EntityManagerFactory객체를 반환한다.

```java
em.close();
emf.close();
```


