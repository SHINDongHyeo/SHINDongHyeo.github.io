# 정렬
기본적으로 오름차순으로 정렬하는 알고리즘에 대해 공부하고 코드를 작성해본다.

```python
###################### < 오름차순 정렬 방법들 > ######################
import random
arr=[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]
random.shuffle(arr)
print('랜덤배열 : ',arr)

#----------- 선택정렬 O( n^2 ) -----------#
def select_sort(arr):
    for i in range(len(arr)):
        min_idx = i # 기준인 i번째 인덱스값이 가장 작다고 가정
        for j in range(i+1,len(arr)): # i번째 뒤쪽 인덱스를 모두 훑으면서 가장 작다고 가정된 i번째 값보다 작은 값을 찾으며 최솟값을 갱신한다.
            if arr[min_idx] > arr[j]:
                min_idx = j # 새로운 최솟값 갱신
        arr[i],arr[min_idx]=arr[min_idx],arr[i] # 스왑
    return arr
print('선택정렬 : ',select_sort(arr))

#----------- 삽입정렬 O( n^2 ) -----------#
def insert_sort(arr):
    for i in range(1,len(arr)):
        for j in range(1,i+1):
            if arr[i-j] > arr[i+1-j]: # 새로운 기준값이 바로 왼쪽값보다 작으면 스왑
                arr[i-j],arr[i+1-j]=arr[i+1-j],arr[i-j] # 스왑
            else:
                break
    return arr
print('삽입정렬 : ',insert_sort(arr))

#----------- 퀵정렬 O( nlog(n) ) -----------#
def quick_sort(arr):
    if len(arr) < 2:
        return arr
    
    pivot = 0  # pivot, i(끝에서부터왼쪽, pivot보다작은값), j(pivot에서부터오른쪽, pivot보다큰값)
    i=len(arr)-1
    j=pivot+1
    while True:
        while arr[pivot] < arr[i]:
            i-=1
        while arr[pivot] > arr[j]:
            j+=1
            if j == len(arr):
                break
        
        if i < j: # i와 j가 엇갈린 경우
            arr[pivot],arr[i]=arr[i],arr[pivot] # 이제 arr[i]는 고정 / arr[i]을 pivot으로 왼쪽, 오른쪽 또 정렬해주면 된다.
            break
        else: # 아직 엇갈리지 않은 경우
            arr[i],arr[j]=arr[j],arr[i]

    return quick_sort(arr[:i])+[arr[i]]+quick_sort(arr[i+1:])
print(' 퀵 정렬 : ',quick_sort(arr))

#----------- 병합정렬 O( nlog(n) ) -----------#
def merge_sort(arr):
    if len(arr) < 2:
        return arr
    
    mid = len(arr) // 2

    left = arr[:mid] # 리스트를 반으로 나누기
    right = arr[mid:]

    left_merging = merge_sort(left) # 리스트길이가 1이 되어 return될때까지 계속 재귀
    right_merging = merge_sort(right)

    # 여기서부터 리스트길이가 1이되어 arr가 return되며, 다시 거슬러 올라가는 부분 (left_merging 과 right_merging 의 값이 구해진 시점 이후)
    merging=[]  # left_merging과 right_merging이 정렬되며 합쳐질 리스트 선언-----------------------------------------------------------
    l_idx = 0
    r_idx = 0
    l_max = len(left_merging)-1
    r_max = len(right_merging)-1
    while  (l_idx <= l_max) and (r_idx <= r_max):
        if left_merging[l_idx] < right_merging[r_idx]:
            merging.append(left_merging[l_idx])
            l_idx += 1
        else:
            merging.append(right_merging[r_idx])
            r_idx += 1
    # left_merging 이나 right_merging 중 한 쪽이 모두 merging으로 들어가 while문 종료된 시점. 나머지 부분 붙여준다.

    if l_idx > l_max: # left_merging이 모두 소비된 경우
        merging.extend(right_merging[r_idx:])

    else:              # right_merging이 모두 소비된 경우
        merging.extend(left_merging[l_idx:])
    # ------------------------------------------------merging 완성---------------------------------------------------------------------
    return merging
print('병합정렬 : ',merge_sort(arr))
```